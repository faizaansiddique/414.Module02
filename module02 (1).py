# -*- coding: utf-8 -*-
"""Module02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-CLpllfR0s-VbzgySmUVQIzUEeU79hrj
"""

import pandas as pd
import matplotlib.pyplot as plt
import networkx as nx

#Load raw data

f_path = '/List of most-followed Instagram accounts.csv'
df = pd.read_csv(f_path)


df.head()

#Data cleaning

#Split primary and secondary professions
def split_professions(profession):
    if isinstance(profession, str):
        # Replace ' And ' with ',' to handle all as a list of professions
        parts = [p.strip() for p in profession.replace(' And ', ',').split(',')]
        primary = parts[0]
        secondary = ', '.join(parts[1:]) if len(parts) > 1 else ''
        return pd.Series([primary, secondary])
    return pd.Series([profession, ''])

# Apply the split to the column
df[['Primary Profession', 'Secondary Professions']] = df["Profession/Activity"].apply(split_professions)


#Delete irrelevant columns (Secondary professions, country)
df_clean = df[['Username', 'Owner', 'Followers(millions)[2]', 'Primary Profession', ]].dropna()

#Clean and consolidate professions
def consolidate_profession(profession):
    if not isinstance(profession, str):
        return profession

    #Remove invalid entry
    if profession == 'As of 4\xa0January\xa02023':
        return None

    profession = profession.lower()

    if any(term in profession for term in ['actor', 'actress']):
        return 'Acting'
    elif any(term in profession for term in ['basketball player', 'cricketer', 'footballer', 'professional wrestler']):
        return 'Athlete'
    elif any(term in profession for term in [
        'club basketball competition', 'club football competition',
        'football club', 'magazine', 'social media platform',
        'space agency', 'sportswear multinational'
    ]):
        return 'Professional Organization'
    elif any(term in profession for term in ['businesswoman', 'president of inter miami']):
        return 'Business'
    elif 'model' in profession and 'television personality' not in profession:
        return 'Model'
    elif 'television personality' in profession:
        return 'Television Personality'
    elif 'musician' in profession:
        return 'Musician'
    elif 'comedian' in profession:
        return 'Comedian'
    elif 'social media personality' in profession:
        return 'Social Media Personality'
    else:
        return profession.title()

#Apply consolidation
df_clean['Primary Profession'] = df_clean['Primary Profession'].apply(consolidate_profession)

#Drop any rows with None in 'Primary Profession' after cleanup
df_clean = df_clean.dropna(subset=['Primary Profession'])

df_clean.head()

#Print list of raw unique professions before cleaning
raw_unique_professions = df['Profession/Activity'].unique().tolist()
raw_unique_professions

#Print list of cleaned unique professions
cleaned_unique_professions = df_clean['Primary Profession'].unique().tolist()
cleaned_unique_professions

#Network Graph

# Create the graph
G = nx.Graph()

for _, row in df_clean.iterrows():
    G.add_node(row['Owner'], type='Person')
    G.add_node(row['Primary Profession'], type='Profession')
    G.add_edge(row['Owner'], row['Primary Profession'])

#Draw the network
plt.figure(figsize=(15, 10))
pos = nx.spring_layout(G, k=0.3)

person_nodes = [n for n, attr in G.nodes(data=True) if attr['type'] == 'Person']
profession_nodes = [n for n, attr in G.nodes(data=True) if attr['type'] == 'Profession']

nx.draw_networkx_nodes(G, pos, nodelist=person_nodes, node_color='lightblue', node_size=300, label='Account Owner')
nx.draw_networkx_nodes(G, pos, nodelist=profession_nodes, node_color='lightgreen', node_size=900, label='Profession')
nx.draw_networkx_edges(G, pos, alpha=0.8)
nx.draw_networkx_labels(G, pos, font_size=6)

plt.title("Top Instagram Accounts and Their Primary Professions")
plt.axis('off')
plt.legend(scatterpoints=1)
plt.show()

#Analysis

#Calculate degree centrality
degree_centrality = nx.degree_centrality(G)
profession_centrality = {node: centrality for node, centrality in degree_centrality.items() if G.nodes[node]['type'] == 'Profession'}

#Create a DataFrame from profession centrality dictionary
profession_centrality_df = pd.DataFrame(
    list(profession_centrality.items()),
    columns=['Profession', 'Degree Centrality']
)

#Sort by degree centrality in descending order
profession_centrality_df = profession_centrality_df.sort_values(by='Degree Centrality', ascending=False)
print(profession_centrality_df)

#Calculate number of owners per profession category
profession_counts = df_clean['Primary Profession'].value_counts().reset_index()
profession_counts.columns = ['Profession', 'Number of Users']
print(profession_counts)